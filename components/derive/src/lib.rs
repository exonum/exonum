// Copyright 2019 The Exonum Team
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! This crate provides macros for deriving some useful methods and traits for the exonum services.

#![recursion_limit = "256"]
#![deny(unsafe_code, bare_trait_objects)]
#![warn(missing_docs, missing_debug_implementations)]

extern crate proc_macro;

mod pb_convert;
mod service_factory;
mod service_interface;

use proc_macro::TokenStream;
use quote::quote;
use syn::{Lit, Meta, MetaList, MetaNameValue, NestedMeta, Path};

// Exonum derive attribute names, used as
// `#[exonum( [ ATTRIBUTE_NAME = ATTRIBUTE_VALUE or ATTRIBUTE_NAME ],* )]`
const CRATE_PATH_ATTRIBUTE: &str = "crate";
const PB_CONVERT_ATTRIBUTE: &str = "pb";
const SERDE_PB_CONVERT_ATTRIBUTE: &str = "serde_pb_convert";
const ARTIFACT_NAME: &str = "artifact_name";
const ARTIFACT_VERSION: &str = "artifact_version";
const PROTO_SOURCES: &str = "proto_sources";
const SERVICE_CONSTRUCTOR: &str = "with_constructor";
const SERVICE_DISPATCHER: &str = "dispatcher";

/// Derives `ProtobufConvert` trait.
///
/// Attributes:
///
/// ## Required
///
/// * `#[exonum(pb = "path")]`
///
/// Path is the name of the corresponding protobuf generated struct.
///
/// ## Optional
///
/// * `#[exonum(crate = "path")]`
///
/// Prefix of the `exonum` crate(usually "crate" or "exonum").
///
/// * `#[exonum(serde_pb_convert)]`
///
/// Implements `serde::{Serialize, Deserialize}` using structs that were generated with
/// protobuf.
/// For example, it should be used if you want json representation of your struct
/// to be compatible with protobuf representation (including proper nesting of fields).
/// ```text
/// For example, struct with `exonum::crypto::Hash` with this
/// (de)serializer will be represented as
/// StructName {
///     "hash": {
///         data: [1, 2, ...]
///     },
///     // ...
/// }
/// // With default (de)serializer.
/// StructName {
///     "hash": "12af..." // HEX
///     // ...
/// }
/// ```
#[proc_macro_derive(ProtobufConvert, attributes(exonum))]
pub fn generate_protobuf_convert(input: TokenStream) -> TokenStream {
    pb_convert::implement_protobuf_convert(input)
}

/// Derives `ServiceFactory` trait.
///
/// # Attributes:
///
/// ## Required
///
/// * `#[exonum(proto_sources = "path")]`
///
/// Path to the module that was generated by the `exonum_build::protobuf_generate`
/// and contains the original protobuf source files of the service.
///
/// ## Optional
///
/// * `#[exonum(crate = "path")]`
///
/// Prefix of the `exonum` crate(usually "crate" or "exonum").
///
/// * `[#exonum(artifact_name = "string")]`
///   
/// Overrides artifact name, by default it uses crate name.
///
/// * `[#exonum(artifact_version = "string")]`
///
/// Overrides artifact version, by default it uses crate version.
///
/// * `[#exonum(with_constructor = "path")]`
///
/// Overrides service constructor by the custom function with the following signature:
///
/// `Fn(&ServiceFactoryImpl) -> Box<dyn Service>`.
///
/// # Examples
///
/// Typical usage.
/// ```ignore
/// #[derive(ServiceFactory)]
/// #[exonum(proto_sources = "crate::proto")]
/// pub struct MyService;
/// ```
///
/// But if you have complex logic in service factory you can use custom constructor to create a
/// new service instances.
/// ```ignore
/// // Imagine that you have a stateful service like this
/// #[derive(Debug)]
/// pub struct TimeService {
///     /// Current time.
///     time: Arc<dyn TimeProvider>,
/// }
///
/// // You can implement service factory, but you cannot just derive `ServiceFactory`
/// // like in example bellow.
/// // To resolve this problem you can specify your own constructor for the service instance.
/// #[derive(Debug, ServiceFactory)]
/// #[exonum(
///     proto_sources = "proto",
///     with_constructor = "TimeServiceFactory::create_instance"
/// )]
/// pub struct TimeServiceFactory {
///     time_provider: Arc<dyn TimeProvider>,
/// }
///
/// // Arbitrary constructor implementation.
/// impl TimeServiceFactory {
///     fn create_instance(&self) -> Box<dyn Service> {
///         Box::new(TimeService {
///             time: self.time_provider.clone(),
///         })
///     }
/// }
/// ```
#[proc_macro_derive(ServiceFactory, attributes(exonum))]
pub fn generate_service_factory(input: TokenStream) -> TokenStream {
    service_factory::implement_service_factory(input)
}

/// TODO [ECR-3275]
#[proc_macro_attribute]
pub fn service_interface(attr: TokenStream, item: TokenStream) -> TokenStream {
    service_interface::impl_service_interface(attr, item)
}

/// Exonum types should be imported with `crate::` prefix if inside crate
/// or with `exonum::` when outside.
fn get_exonum_types_prefix(attrs: &[Meta]) -> impl quote::ToTokens {
    let map_attrs = get_exonum_name_value_attributes(attrs);
    let crate_path = map_attrs.into_iter().find_map(|nv| match &nv {
        MetaNameValue {
            lit: Lit::Str(path),
            ident,
            ..
        } if ident == CRATE_PATH_ATTRIBUTE => Some(
            path.parse::<Path>()
                .expect("failed to parse crate path in the attribute"),
        ),
        _ => None,
    });

    if let Some(path) = crate_path {
        quote!(#path)
    } else {
        quote!(exonum)
    }
}

/// Extract attributes in the form of `#[exonum(name = "value")]`
fn get_exonum_attributes(exonum_meta: Option<Meta>) -> Vec<Meta> {
    match exonum_meta {
        Some(Meta::List(MetaList { nested: list, .. })) => list
            .into_iter()
            .filter_map(|n| match n {
                NestedMeta::Meta(meta) => Some(meta),
                _ => None,
            })
            .collect(),
        Some(_) => panic!("`exonum` attribute should contain list of name value pairs"),
        None => vec![],
    }
}

fn get_exonum_name_value_attributes(meta_attrs: &[Meta]) -> Vec<MetaNameValue> {
    let exonum_meta = meta_attrs.iter().find(|m| m.name() == "exonum").cloned();

    get_exonum_attributes(exonum_meta)
        .into_iter()
        .filter_map(|meta| match meta {
            Meta::NameValue(name_value) => Some(name_value),
            _ => None,
        })
        .collect()
}

fn find_exonum_word_attribute(meta_attrs: &[Meta], ident_name: &str) -> bool {
    let exonum_meta = meta_attrs.iter().find(|m| m.name() == "exonum").cloned();

    get_exonum_attributes(exonum_meta)
        .iter()
        .any(|meta| match meta {
            Meta::Word(ident) if ident == ident_name => true,
            _ => false,
        })
}

fn find_attribute_path(meta_attrs: &[Meta], name: &str) -> Option<Path> {
    let map_attrs = get_exonum_name_value_attributes(meta_attrs);
    map_attrs.into_iter().find_map(|nv| {
        if nv.ident == name {
            match nv.lit {
                Lit::Str(path) => Some(path.parse::<Path>().unwrap()),
                _ => None,
            }
        } else {
            None
        }
    })
}
